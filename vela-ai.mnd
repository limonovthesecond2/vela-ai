//
// Main Processor
//
const defendRange = 18    // Defend range
const repAppr = 2    // Repair approach distance
const repNotFar = 200    // Max repair distance
const vaultRange = 6    // Vault approach distance
const idleRange = 14    // Idle distance
const unitApprRange = 8    // Distance to approach the enemy if can't land
const nullPoint = -100    // Null point
const spawnRange = 60    // Enemy spawn range
const unitSearchRange = 5    // Search range of enemy units

ubind(@vela)
isKamikaze = @unit.flag    // Use flag(1) to skip repair
if isKamikaze == 0    // Unit repair logic
    hp = @unit.health
    maxRepHp = cell1[0]
    if hp < maxRepHp
        found = ulocate(building, repair, false, outx, outy, building)
        if found == 1
            power = building.totalPower
            if power > 0
                isNear = within(outx, outy, defendRange)
                if isNear == 1
                    approach(outx, outy, repAppr)
                    autoDefend()
                    end()
                else
                    minRepHp = cell1[1]
                    if hp <= minRepHp
                        isNotFar = within(outx, outy, repNotFar)
                        if isNotFar == 1
                            boost(1)
                            approach(outx, outy, repAppr)
                            end()
                        end
                    end
                end
            end
        end
    end
end

items = @unit.totalItems
unitCap = @unit.itemCapacity
if items < unitCap    // Bomb loading logic
    bombType = sorter1.config
    if bombType != null
        if vault1 != null
            outx = vault1.x
            outy = vault1.y
            approach(outx, outy, vaultRange)
            isNear = within(outx, outy, defendRange)
            if isNear == 1
                autoDefend()
                itemTake(vault1, bombType, unitCap)
                end()
            else
                boost(1)
                end()
            end
        end
    end
end

flag(0)    // Reset flag
isEnabled = cell1[21]
if isEnabled == 0    // Idle logic
    if vault1 == null    // If no vault, approach to this processor
        outx = @this.x
        outy = @this.y
    else
        outx = vault1.x
        outy = vault1.y
    end
    approach(outx, outy, idleRange)
    isNear = within(outx, outy, defendRange)
    if isNear == 1
        autoDefend()
        end()
    else
        boost(1)
        end()
    end
end

inline def autoDefend()
    enUnit = uradar(enemy, any, any, distance, 1)
    if enUnit != null
        boost(0)
        targetp(enUnit, 1)
        end()
    end
    unitRange = @unit.range
    enTurr = ulocate(building, turret, true, outx, outy, 0)
    if enTurr == 1
        targetBuilding(outx, outy, unitRange)
    end
    damAlly = ulocate(damaged, outx, outy, 0)
    if damAlly == 1
        targetBuilding(outx, outy, unitRange)
    end
    boost(1)    // If no enemy nearby, fly to not swim in water or lava

    inline def targetBuilding(outx, outy, unitRange)
        isNear = within(outx, outy, unitRange)
        if isNear == 1
            boost(0)
            target(outx, outy, 1)
            end()
        end
    end
end

// Auto attack logic
enUnit = uradar(enemy, any, any, maxHealth, 1)
if enUnit != null
    enMaxHp = enUnit.maxHealth
    dangEnemy = cell1[13]
    if enMaxHp >= dangEnemy
        boost(0)
        targetp(enUnit, 1)
        outx = enUnit.x
        outy = enUnit.y
        cell1[10] = outx
        cell1[11] = outy
        isBoosted = @unit.boosting
        if isBoosted == 1
            approach(outx, outy, unitApprRange)
            end()
        else
            attackRange = cell1[12]
            approach(outx, outy, attackRange)
            end()
        end
    end
end
unitRange = @unit.range
enTurr = ulocate(building, turret, true, outx, outy, 0)
if enTurr == 1
    autoAttack(outx, outy, unitRange)
end
enCore = ulocate(building, core, true, outx, outy, 0)
if enCore == 1
    autoAttack(outx, outy, unitRange)
end
enGener = ulocate(building, generator, true, outx, outy, 0)
if enGener == 1
    autoAttack(outx, outy, unitRange)
end

inline def autoAttack(outx, outy, unitRange)
    isNear = within(outx, outy, unitRange)
    if isNear == 1
        boost(0)
        target(outx, outy, 1)
        isBoosted = @unit.boosting
        if isBoosted == 1    // Kamikaze attack if can't land
            move(outx, outy)
            flag(1)
            end()
        else
            approach(outx, outy, unitRange)
            end()
        end
    end
end

isControll = arc1.controlled
if isControll == 2    // Manual controll
    outx = arc1.shootX
    outy = arc1.shootY
    apprRange = unitRange * 1.2
    isNear = within(outx, outy, apprRange)
    if isNear == 1
        isShooting = arc1.shooting
        if isShooting == 1
            boost(0)
            target(outx, outy, isShooting)
            isBoosted = @unit.boosting
            if isBoosted == 1
                move(outx, outy)
                flag(1)
                end()
            else
                attackRange = cell1[12]
                approach(outx, outy, attackRange)
                end()
            end
        else
            boost(1)
            move(outx, outy)
            end()
        end
    end
    boost(1)
    approach(outx, outy, unitRange)
    end()
end

gameMode = cell1[20]
if gameMode == 0
    boost(1)
    autoPathfind()
    end()
else
    outx = cell1[10]
    if outx == nullPoint    // Approach to spawn if no enemy units found
        autoPathfind()
        enSpawn = ulocate(spawn, outx, outy, 0)
        if enSpawn == 1
            isNear = within(outx, outy, spawnRange)
            if isNear == 1
                unitX = @unit.x
                unitY = @unit.y
                getBlock(unitX, unitY, 0, 0, floor)    // Check floor under unit
                if floor != @deep-water
                    if floor != @molten-slag
                        boost(0)    // Landing for repairs
                        target(0, 0, 0)    // Make unit not fire at last target
                        end()
                    end
                end
            end
        end
        boost(1)
        end()
    else
        outy = cell1[11]
        boost(1)
        move(outx, outy)    // Approach to enemy unit
        isNear = within(outx, outy, unitSearchRange)
        if isNear == 1
            cell1[10] = nullPoint    // If code reached this point, there are no enemy units around
        end
    end
end


//
// Cell Processor
//
const nullPoint = -100

while true
    ubind(@vela)
    if cell1 != null
        if @unit != null
            maxHp = @unit.maxHealth
            unitRange = @unit.range
            isDead = @unit.dead
            if isDead != 1    // If unit died after bind @unit != null, but dead == 1. Check it to get correct values instead of null
                maxRepHp = maxHp * 0.90    // Max hp to repair
                cell1[0] = maxRepHp
                minRepHp = maxHp * 0.5    // Min hp to repair
                cell1[1] = minRepHp
                cell1[10] = nullPoint    // Enemy unit X
                cell1[11] = nullPoint    // Enemy unit Y

                while cell1 != null    // Check is cell is still alive
                    isControll = arc1.controlled
                    if isControll == 2
                        cell1[21] = 1
                        switch1.enabled = 1
                    else
                        isEnabled = switch1.enabled
                        cell1[21] = isEnabled
                    end

                    enCore = ulocate(building, core, true, 0, 0, 0)
                    if enCore == 1
                        cell1[12] = unitRange    // Approach range to enemy unit
                        cell1[13] = 600    // Min hp for dangerous enemy
                        cell1[20] = 0    // Attack mode (approach to cores)
                    else
                        isDead = @unit.dead
                        if isDead != 1
                            attackRange = unitRange * 0.8    // Closer than unitRange to not lose enemy when shooting
                            cell1[12] = attackRange
                            cell1[13] = 0    // Attack all units
                            cell1[20] = 1    // Survival mode (approach to enemy units first)
                        else
                            break
                        end
                    end
                    wait(0.2)    // No need to check frequently
                end
            end
        end
    end
end


//
// Message Processor
//
print("[pink]Vela AI (auto Attack logIc)\n[]Click switch to toggle [red]attack[]/[green]idle[].\nUnits attack enemy, approach to cores and spawns, repair at nearest building if not too far. You can control units in arc turret\n\n by [orange]testt []in 24-01-29\n inspired by [orange]|DE|Пастаф\n [][cyan]ver. 2.5[]\n\nUnits ")
isEnabled = switch1.enabled
if isEnabled == 0
    print("are [green]Idle")
else
    print("[red]Attack")
end
print("\n\n[]Source code with comments: [cyan]github.com/limonovthesecond2/vela-ai")
printflush(message1)

bomb = sorter1.config
if bomb != null
    i = 0
    while true
        block = getlink(i)
        blockType = block.type
        case blockType
            when @unloader, @item-source then
                block.config = bomb
        end
        i += 1
        if i >= @links
            end()
        end
    end
else
    wait(1)
end
